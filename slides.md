---
marp: false
title: Agentic Coding Recommendations
description: 에이전트 기반 개발을 위한 실전 가이드
author: Dohyun Jung
theme: default
paginate: true
size: 16:9
---

# Agentic Coding Recommendations  
#### 정도현(Roboco) · 2025-06-26

---

## Agenda
1. Why Agentic Coding?
2. The Basics
3. Language Choice
4. Tools, Tools, Tools
5. Speed & Stability
6. Simplicity First
7. Parallelization
8. Refactoring Mindset
9. Key Takeaways

---

## The Basics
- **권한 확인 비활성화** → 빠른 루프  
- **MCP는 최소화**  
  - 일반 쉘/스크립트로 충분하면 그대로 사용  
- **도커 샌드박스 권장** (위험 완화)  
- **IDE 의존 최소화** → IDE + 터미널상에서 Claude Code

<!--
**Presenter Notes:**
- 이 파트는 에이전트에게 최대한 자유롭게 작업을 맡기고, 개발자는 관리와 방향 제시에 집중하는 워크플로우를 의미합니다.
- 권한 확인을 비활성화하면 반복 루프가 빨라집니다. 다만, 위험을 줄이기 위해 도커 샌드박스 환경을 권장합니다.
- MCP(도구 표준화 프로토콜)는 꼭 필요할 때만 사용하고, 일반 쉘/스크립트로 충분하면 그대로 두는 것이 효율적입니다.
- IDE 의존도를 줄이면, 에이전트가 코드 작성에 집중하고, 개발자는 최종 편집만 하면 됩니다.
- 실무에서는 에이전트가 한 번에 고려해야 할 정보가 많아질수록 관리가 어려워지므로, 적절한 시점에 구조화와 리팩터링이 필요합니다.
-->

---

## Language Choice
> “Go is sloppy — perfect for agents.” – Armin Ronacher
- **Go 추천**  
  - `context` 패턴이 명시적  
  - 테스트 캐싱으로 빠른 루프  
  - 구조적 인터페이스 → LLM 친화  
  - 생태계 변화 적음
- Python/Rust는 **해석·빌드 지연**문제 및 **트릭이 많은 문법**으로 인해 AI가 실수할 확률이 높음

<!--
**Presenter Notes:**
- 에이전트가 친숙한 언어와 환경을 제공하면 작업 정확도와 속도가 올라갑니다.
- Go는 context 전달이 명확하고, 테스트 캐싱이 잘 되어 반복 작업이 빠릅니다.
- 구조적 인터페이스 덕분에 LLM이 타입을 쉽게 이해할 수 있습니다.
- 생태계 변화가 적어, 에이전트가 예측 가능한 코드를 생성합니다.
- Python/Rust는 빌드/실행 지연, 매직(숨겨진 동작) 때문에 에이전트가 실수하기 쉽습니다.
- 실무에서는 Makefile에 테스트, 린터, 로그 명령을 정리해두면 에이전트가 쉽게 활용할 수 있습니다.
-->

---

## Tools, Tools, Tools
- **무엇이든 도구** (스크립트·로그·MCP 서버)  
- 핵심 4원칙  
  1. 빠를 것  
  2. 명확한 오류 메시지  
  3. 실패(크래시)는 OK, **행(hang)은 NO**  
  4. 관찰성·디버그 용이  
- `Makefile` 활용:  
  - `make dev`, `make tail-log` 예시  
  - **PID 잠금**으로 중복 기동 방지

<!--
**Presenter Notes:**
- 도구란 린터, 테스트, 로그, 개발 서버 등 에이전트가 사용할 수 있는 모든 것을 의미합니다.
- 도구는 빠르고, 명확한 오류 메시지를 주며, 크래시는 괜찮지만 멈춤(hang)은 절대 안 됩니다.
- 관찰성과 디버깅이 쉬워야 에이전트가 문제를 진단하고 해결할 수 있습니다.
- Makefile에 주요 명령을 정리해두면 에이전트가 쉽게 접근할 수 있습니다.
- 예시: PID 잠금으로 중복 기동을 막아, 에이전트가 서버를 여러 번 띄우는 실수를 방지합니다.
- 로그를 stdout에 남기고, 문서에 위치를 명시하면 에이전트가 필요한 정보를 직접 찾아 처리할 수 있습니다.
-->

---

## Speed Matters
- 추론 비용 + 툴 지연 = 생산성 저하  
- **컴파일·부트 시간 최소화**  
  - 경량 스크립트 → 3 ms  
  - 무거운 서비스 재시작 → 60 s ❌  
- 필요 시 **핫 리로드용 데몬** 작성  
- 로그는 **간결 + 유의미 + 토글 가능**

<!--
**Presenter Notes:**
- 에이전트의 작업 속도는 도구와 환경 설정에 크게 좌우됩니다.
- 반복 작업(테스트, 빌드 등)이 빠를수록 에이전트가 더 자주, 더 효과적으로 피드백을 받을 수 있습니다.
- 빌드/테스트 속도를 최적화해 빠른 피드백 루프를 만드세요.
- 예시: 테스트가 느리면 에이전트가 작은 변경에도 오래 기다려야 하므로, 병렬화나 캐싱을 활용해 속도를 높입니다.
- 로그는 꼭 필요한 정보만, 간결하게 남기고, 필요에 따라 토글할 수 있게 설계하세요.
-->

---

## Stability & Copy/Paste
- **의존성 업그레이드**는 보수적으로  
  - LLM breadcrumb / 주석과 충돌 방지  
- “Build It Yourself” – 라이브러리보다 **직접 구현** 선호  
- 고정된 생태계 = 예측 가능한 코드 생성

<!--
**Presenter Notes:**
- 예측 가능한 결과와 일관된 동작이 중요합니다.
- 의존성 업그레이드는 보수적으로 진행해, LLM이 남긴 주석이나 결정과 충돌하지 않게 합니다.
- 가능하면 직접 구현(Build It Yourself) 방식을 선호해, 에이전트가 코드를 더 잘 이해하고 유지보수할 수 있게 합니다.
- 고정된 생태계는 에이전트가 예측 가능한 코드를 생성하는 데 도움이 됩니다.
- 예시: 디버그 모드에서 이메일을 실제로 보내지 않고 로그에 남기면, 에이전트가 로그만 보고 인증 플로우를 자동화할 수 있습니다.
-->

---

## Write Simple Code
- “Dumbest possible thing that works”  
- 긴 이름의 **함수 중심** 코드  
- 상속 피하기, **ORM 보다 SQL**  
- **권한 체크**는 코드 근처에! (AI가 인지하기 쉽게)

<!--
**Presenter Notes:**
- 복잡성을 줄이고, 명확하고 단순한 구조를 유지해야 에이전트가 전체 맥락을 이해하기 쉽습니다.
- 함수 중심, 긴 이름, 상속 대신 조합, ORM보다 SQL 등 단순한 패턴을 권장합니다.
- 권한 체크는 코드 근처에 명확히 두어, 에이전트가 놓치지 않게 합니다.
- 실무에서는 기능별로 파일과 컴포넌트를 분리하고, 불필요한 중복을 제거하세요.
-->

---

## Make It Parallelizable
- 에이전트 **단일 속도는 느림** → 다중 인스턴스  
- 상태 격리: 별도 체크아웃·DB·Redis 샤드  
- `container-use` 등 MCP로 컨테이너 격리 실험

<!--
**Presenter Notes:**
- 에이전트가 여러 작업을 동시에 처리할 수 있도록 설계하면 전체 개발 속도가 빨라집니다.
- 테스트, 빌드, 코드 생성 등 반복 작업을 병렬로 실행하세요.
- 상태 격리를 위해 별도 체크아웃, DB, Redis 샤드 등을 활용할 수 있습니다.
- MCP의 container-use 등으로 컨테이너 격리 실험도 가능합니다.
-->

---

## Learn to Refactor
- **타이밍**이 관건  
  - 너무 이르면 낭비, 늦으면 LLM 혼란  
- 복잡도가 높아지는 시점이 컴포넌트 라이브러리 분리 시점  
- 리팩터 단계에도 **에이전트** 적극 활용

<!--
**Presenter Notes:**
- 리팩터링의 시점과 범위를 신중하게 결정해야 합니다.
- 너무 이르거나 늦은 리팩터링은 오히려 비효율적입니다.
- 에이전트가 작업하기 힘들어질 때가 적기입니다.
- 예시: Tailwind 클래스가 너무 많아져서 에이전트가 컴포넌트 추출을 못할 때, 그 시점에 구조화 작업을 지시하세요.
- 리팩터 단계에도 에이전트를 적극 활용할 수 있습니다.
-->

---

## Key Takeaways
1. **속도**: 짧은 피드백 루프  
2. **단순성**: Go, 간단한 도구, 명료한 코드  
3. **관찰성**: 로그 + PID 보호  
4. **안전 병렬화**: 컨테이너 격리  
5. **적시 리팩터**로 복잡도 통제

---

## References
- Armin Ronacher, “Agentic Coding Recommendations” (2025-06-12)  
  <https://lucumr.pocoo.org/2025/6/12/agentic-coding/>  
- 기타: Playwright-MCP, container-use, Cursor Background Agents

---

# Q&A  
감사합니다!