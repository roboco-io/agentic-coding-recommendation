---
marp: false
title: Agentic Coding Recommendations
description: エージェントベース開発のための実践ガイド
author: Dohyun Jung
theme: default
paginate: true
size: 16:9
---

# Agentic Coding Recommendations  
#### 鄭道鉉（Roboco） · 2025-06-26

---

## 自己紹介
- 名前: 鄭道鉉(ジョンドヒョン)
- 経験
  - 95年からFrontend Developer
  - 2002年から2016年まで日本でITコンサルティングとシステム開発を経験
    - 豆蔵でITコンサルタントとして勤務
  - 2016年からAWS Korea Sr.Technical Trainer,Sr.SDE
  - 2025年からRoboco 代表取締役
- 趣味: バイブコーディング, Cycling

---

## Roboco
- 自分を含め、合計4人が所属
- アマゾンとグーグル出身のエンジニアが中心となって設立
- メンバー一人一人が独立したソフトウェア開発会社のように運営

---

## 発表資料について

この発表は、Armin Ronacher氏のブログ - [Agentic Coding Recommendations](https://lucumr.pocoo.org/2025/6/12/agentic-coding/)記事をChatGPTで発表者ノート付き[Marp(Markdown Presentation Ecosystem)](https://marp.app/)に変換したものである

https://github.com/roboco-io/agentic-coding-recommendation/


---
## アジェンダ
1. Why Agentic Coding?
2. The Basics
3. Language Choice
4. Tools, Tools, Tools
5. Speed & Stability
6. Simplicity First
7. Parallelization
8. Refactoring Mindset
9. Key Takeaways

---

## The Basics
- **権限確認を無効化** 
  - `claude --dangerously-allow-permissions` → 高速ループ  
- **MCPは最小限**  
  - 通常のシェルスクリプトで十分
  - 自分はPlaywrightとPerplexity-askを活用
- **Dockerサンドボックス推奨** （リスク軽減）  
- **IDE依存を最小化**

<!--
**Presenter Notes:**
- この部分は、エージェントに最大限自由に作業を任せ、開発者は管理と方向性の提示に集中するワークフローを意味します。
- 権限確認を無効化すると、反復ループが高速になります。ただし、リスクを軽減するため、Dockerサンドボックス環境を推奨します。
- MCP（ツール標準化プロトコル）は必要な時だけ使用し、通常のシェル/スクリプトで十分な場合はそのまま使用するのが効率的です。
- IDE依存度を下げれば、エージェントがコード作成に集中し、開発者は最終編集のみで済みます。
- 実務では、エージェントが一度に考慮すべき情報が多くなるほど管理が困難になるため、適切なタイミングでの構造化とリファクタリングが必要です。
-->

---

## Language Choice
> "Go is sloppy — perfect for agents." – Armin Ronacher
- **Go推奨**  
  - `context`パターンが明示的  
  - テストキャッシュで高速ループ  
  - 構造的インターフェース → LLMフレンドリー  
  - エコシステムの変化が少ない
- Python/Rustは **解釈・ビルド遅延**と**マジック**で難易度↑

<!--
**Presenter Notes:**
- エージェントに親しみやすい言語と環境を提供すれば、作業精度と速度が向上します。
- Goはcontext渡しが明確で、テストキャッシュが優秀なため反復作業が高速です。
- 構造的インターフェースにより、LLMが型を理解しやすくなります。
- エコシステムの変化が少ないため、エージェントが予測可能なコードを生成します。
- Python/Rustはビルド/実行遅延、マジック（隠された動作）のため、エージェントがミスしやすいです。
- 実務では、Makefileにテスト、リンター、ログコマンドを整理しておけば、エージェントが簡単に活用できます。
-->

---

## Tools, Tools, Tools
- **VibeCodingでもツールは重要です** （スクリプト・ログ・MCPサーバー）  
- 核心4原則  
  1. 高速であること  
  2. 明確なエラーメッセージ  
  3. 失敗（クラッシュ）はOK、**ハング**はNG  
  4. 観測性・デバッグ容易性  
- `Makefile`活用:  
  - `make dev`、`make tail-log`例  
  - **PIDロック**で重複起動防止

<!--
**Presenter Notes:**
- ツールとは、リンター、テスト、ログ、開発サーバーなど、エージェントが使用できる全てのものを意味します。
- ツールは高速で、明確なエラーメッセージを提供し、クラッシュは構わないがハングは絶対に避けるべきです。
- 観測性とデバッグが簡単でなければ、エージェントが問題を診断・解決できません。
- Makefileに主要コマンドを整理しておけば、エージェントが簡単にアクセスできます。
- 例：PIDロックで重複起動を防ぎ、エージェントがサーバーを複数回起動するミスを防止します。
- ログをstdoutに出力し、ドキュメントに場所を明記すれば、エージェントが必要な情報を直接見つけて処理できます。
-->

---

## Speed Matters
- 推論コスト + ツール遅延 = 生産性低下  
- **コンパイル・ブート時間最小化**  
  - 軽量スクリプト → 3 ms  
  - 重いサービス再起動 → 60 s ❌  
- 必要時は**ホットリロード用デーモン**作成  
- ログは**簡潔 + 有意義 + トグル可能**

<!--
**Presenter Notes:**
- エージェントの作業速度は、ツールと環境設定に大きく左右されます。
- 反復作業（テスト、ビルドなど）が高速であるほど、エージェントがより頻繁に、より効果的にフィードバックを得られます。
- ビルド/テスト速度を最適化して、高速フィードバックループを作成してください。
- 例：テストが遅いとエージェントが小さな変更でも長時間待つ必要があるため、並列化やキャッシュを活用して速度を向上させます。
- ログは必要な情報のみを簡潔に記録し、必要に応じてトグルできるよう設計してください。
-->

---

## Stability & Copy/Paste
- **依存関係のアップグレード**は保守的に  
  - LLM breadcrumb / コメントとの衝突防止  
- "Build It Yourself" – ライブラリより**直接実装**を優先  
- 固定されたエコシステム = 予測可能なコード生成

<!--
**Presenter Notes:**
- 予測可能な結果と一貫した動作が重要です。
- 依存関係のアップグレードは保守的に進め、LLMが残したコメントや判断と衝突しないようにします。
- 可能な限り直接実装（Build It Yourself）方式を優先し、エージェントがコードをより理解・保守しやすくします。
- 固定されたエコシステムは、エージェントが予測可能なコードを生成するのに役立ちます。
- 例：デバッグモードでメールを実際に送信せずログに記録すれば、エージェントがログのみで認証フローを自動化できます。
-->

---

## Write Simple Code
- "Dumbest possible thing that works"  
- 長い名前の**関数中心**コード  
- 継承を避け、**ORMよりSQL**  
- **権限チェック**はコード近くに！（AIが認識しやすく）

<!--
**Presenter Notes:**
- 複雑性を減らし、明確でシンプルな構造を維持することで、エージェントが全体的な文脈を理解しやすくなります。
- 関数中心、長い名前、継承ではなく組み合わせ、ORMよりSQLなど、シンプルなパターンを推奨します。
- 権限チェックはコード近くに明確に配置し、エージェントが見落とさないようにします。
- 実務では、機能別にファイルとコンポーネントを分離し、不要な重複を除去してください。
-->

---

## Make It Parallelizable
- エージェント**単体速度は遅い** → 多重インスタンス  
- 状態分離：別チェックアウト・DB・Redisシャード  
- `container-use`等MCPでコンテナ分離実験

<!--
**Presenter Notes:**
- エージェントが複数のタスクを同時に処理できるよう設計すれば、全体的な開発速度が向上します。
- テスト、ビルド、コード生成など反復作業を並列実行してください。
- 状態分離のため、別チェックアウト、DB、Redisシャードなどを活用できます。
- MCPのcontainer-useなどでコンテナ分離実験も可能です。
-->

---

## Learn to Refactor
- **タイミング**が肝心  
  - 早すぎると無駄、遅すぎるとLLM混乱  
- 複雑度↑ → コンポーネントライブラリ分離タイミング  
- リファクタ段階でも**エージェント**積極活用

<!--
**Presenter Notes:**
- リファクタリングのタイミングと範囲を慎重に決定する必要があります。
- 早すぎたり遅すぎたりするリファクタリングは、むしろ非効率的です。
- エージェントが作業しにくくなった時が適切なタイミングです。
- 例：Tailwindクラスが多すぎてエージェントがコンポーネント抽出できない時、その時点で構造化作業を指示してください。
- リファクタ段階でもエージェントを積極活用できます。
-->

---

## Key Takeaways
1. **速度**：短いフィードバックループ  
2. **シンプル性**：Go、シンプルなツール、明確なコード  
3. **観測性**：ログ + PID保護  
4. **安全な並列化**：コンテナ分離  
5. **適時リファクタ**で複雑度制御

---

## References
- Armin Ronacher, "Agentic Coding Recommendations" (2025-06-12)  
  <https://lucumr.pocoo.org/2025/6/12/agentic-coding/>  
- その他：Playwright-MCP、container-use、Cursor Background Agents

---

# Q&A  
ありがとうございました！